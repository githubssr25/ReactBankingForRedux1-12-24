import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import axios from 'axios';


const initialState = {
    currentUserCustomerID: null,
    isLoggedIn: false,
    status: 'idle', // 'idle', 'loading', 'succeeded', 'failed'
    error: null,
    newCustomerID: null,
  };

  const createInstance = () => axios.create({baseURL: 'http://localhost:9000/api'});

export const loginUser = createAsyncThunk (
'/user/loginUser',
async ({customerID, pin}, { rejectWithValue}) => {
    try {
        const response = await axios.post('http://localhost:9000/api/auth/login', { customerID : customerID, pin: pin, token: null });
        // console.log("printing out response.data right after getting from login call", response.data);
        // Assuming the API returns the user data and a token upon successful login
        const { token } = response.data;
        localStorage.setItem('token', token);
        axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;
        return response.data;
    } catch (error) {
        return rejectWithValue(error.response.data);
    }
});

export const addCustomer = createAsyncThunk('user/loginUser', async ({customerID, pin}) => {
    try {
        const response =  await axios.post("http://localhost:9000/api/auth/addCustomerPractice", {customerID : customerID, pin: pin, authorities: "CUSTOMER"});
        console.log("what is response.data of add customer right as we get return", response.data);
        if(response.status !== 200){
            throw new Error(response.statusText);
            // so after you throw this line 23 catches it 
        }
        return response.data;
    } catch (error){
        throw error;
        // thrown donw here means that outside code that called it will crash and asynch code will be able to receive an error that went bad because asynch code exists to catch ahd handle errors thats why we had to throw it 

    }
});

export const userSlice = createSlice({
name: 'currentUser',
initialState,
reducers : {
    setUser: (state, action) => {
        state.currentUser = action.payload;
        // console.log("does it ever come into set user if so what is state.currentUser", state.currentUser);
    }
}, 
extraReducers: (builder) => {
builder.addCase(loginUser.pending, (state) => {
    state.status = 'loading';
})
.addCase(loginUser.fulfilled, (state, action) => {
    const { user } = action.payload;
    state.currentUserCustomerID = user.customerID; // Directly assign the customerID
    state.isLoggedIn = true;
    state.status = 'succeeded';
    
    // console.log("print out currentUser and action payload", state.currentUserCustomerID, action.payload);
})
.addCase(loginUser.rejected, (state, action) => {
    state.status = 'failed';
    state.error = action.payload;
});

builder.addCase(addCustomer.pending, (state, action) => {
    state.status = 'loading';
  })    
  .addCase(addCustomer.fulfilled, (state, action) => {
    state.status = 'succeeded';
      // Accessing customerID from the nested 'u' object in the payload
  state.newCustomerID = action.payload.u.customerID;
  console.log("Customer registration successful with ID:", state.newCustomerID);
  })
  .addCase(addCustomer.rejected, (state, action) => {
      state.status = 'failed';
    });
}
});

export default userSlice.reducer;


// localStorage.setItem('token', token);
// This line of code stores the authentication token in the browser's localStorage. localStorage is a Web Storage API that allows you to store data as key-value pairs in the
//  user's browser, and this data persists even after the browser window is closed, unlike sessionStorage which clears when the session ends.


// You export userSlice.reducer because the Redux store needs reducer functions to know how to update the state based on dispatched actions.
//  When you set up your Redux store (usually with configureStore in Redux Toolkit), you provide it with a root reducer or a combination of reducers.
// By exporting userSlice.reducer, you are exporting the reducer function generated by createSlice that knows how to handle all actions defined in the reducers and extraReducers fields of your slice.

// If you were to export the entire userSlice object instead of just userSlice.reducer, you would also be exporting the action creators and any other properties included in the slice object. 
// While this might sometimes be useful for certain patterns or advanced use cases, it's not what the Redux store setup typically expects. The Redux store expects reducer functions, not the entire slice object.

// When you use createSlice from Redux Toolkit to define your slice, it returns an object that contains several properties, including:
// actions: An object containing the action creators for the reducers you've defined in the reducers field.
// reducer: The reducer function for this slice, which Redux uses to handle actions and update the state.






// IMPORTANT:
// When you define an async thunk, like loginUser, Redux Toolkit automatically generates action types for each part of its lifecycle: 
// pending, fulfilled, and rejected. These correspond to the async operation's start, successful completion, and failure, respectively.



// extraReducers and builder Function
// In Redux Toolkit, extraReducers is used to handle actions defined outside of the slice, especially those generated by async
//  thunks. The builder function within extraReducers provides a way to respond to these actions.

// builder Function: The builder callback function provides methods to handle additional actions. It allows the slice to respond 
// to other action types, not just the ones generated by the reducers defined within the slice itself.

// addCase Method: This method is used to add a case reducer for a given action type. Each call to addCase takes two arguments: 
// an action creator and a case reducer.
//  The case reducer is a function that takes the current state and an action as arguments and returns a new state.

// builder Function: The builder callback function provides methods to handle additional actions. 
// It allows the slice to respond to other action types, not just the ones generated by the reducers defined within the slice itself.

// addCase Method: This method is used to add a case reducer for a given action type. Each call to addCase takes two arguments:
//  an action creator and a case reducer. The case reducer is a function that takes the current state and an action as arguments and returns a new state.



// To use the stored token for subsequent API requests, you typically retrieve it from localStorage and include it in the request headers. Here's how you might do that:
// const token = localStorage.getItem('token');
// if (token) {
//     instance.defaults.headers.common['Authorization'] = `Bearer ${token}`;
//   }
  

// Why Pass builder?
// The builder argument is passed to extraReducers to provide a fluent interface for adding case reducers for handling actions.
//  It allows you to chain calls to addCase (and other methods like addMatcher and addDefaultCase in Redux Toolkit) for different actions


// Example: Dispatching setUser Action
// Let's say you have a setUser reducer function in your userSlice, and Redux Toolkit has generated an action creator for it. 
// To update the current user in the state, you would dispatch the setUser action with the new user data as the payload.
// Step 1: Define the setUser Reducer
// In your userSlice, you define a reducer function named setUser:
// reducers: {
//     setUser: (state, action) => {
//       state.currentUser = action.payload;
//     },
//   }
// Step 2: Dispatch the Action
// Somewhere in your application, such as in a component after a successful login, you dispatch the setUser action
//  using the generated action creator. 
// You pass the user data as an argument to the action creator, and this data becomes the payload of the action.  
// // Assume userData contains details about the logged-in user
// const userData = { id: 1, name: 'John Doe', email: 'john@example.com' };

// // Dispatch the action with userData as the payload
// dispatch(userSlice.actions.setUser(userData));
// Redux Toolkit's createSlice automatically generates the setUser action creator when you define the setUser reducer.
//  When you call userSlice.actions.setUser(userData), it returns an action object like this:
// {
//   type: 'user/setUser',
//   payload: { id: 1, name: 'John Doe', email: 'john@example.com' }
// }
// Step 3: Reducer Updates the State
// The Redux store receives the dispatched action and forwards it to the userSlice reducer.
//  The setUser reducer function runs, receiving the current state and the dispatched action. 
// It then updates state.currentUser with the action's payload, effectively setting the current user in the Redux state.


// The string '/user/loginUser' in the createAsyncThunk function is not a URL but an action type prefix for the async actions that Redux Toolkit will
//  generate for this thunk. When you use createAsyncThunk, Redux Toolkit automatically creates three action types (pending, fulfilled, and rejected) based on this prefix. For example:

// ${prefix}/pending
// ${prefix}/fulfilled
// ${prefix}/rejected
// In your case, the action types will be:

// user/loginUser/pending
// user/loginUser/fulfilled
// user/loginUser/rejected